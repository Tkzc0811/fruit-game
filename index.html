<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="full-screen" content="yes">
  <title>水果忍者大师版</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a12;
      --bg-glow: #1a0a2e;
      --accent: #ff3366;
      --accent-glow: #ff6b9d;
      --gold: #ffd700;
      --text: #f0f0f5;
      --muted: #6b6b8a;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg-dark);
      font-family: 'Noto Sans SC', sans-serif;
      position: fixed; /* 防止iOS橡皮筋效果 */
      top: 0;
      left: 0;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at 50% 100%, #1a0a2e 0%, #0a0a12 50%, #050508 100%);
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* UI层 */
    .ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    .score-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .score-display {
      font-family: 'Orbitron', monospace;
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 900;
      color: var(--text);
      text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
      transition: transform 0.1s ease;
    }
    .score-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .combo-display {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s ease;
    }
    .combo-display.active {
      opacity: 1;
      transform: scale(1);
    }
    .combo-text {
      font-family: 'Orbitron', monospace;
      font-size: clamp(24px, 5vw, 40px);
      font-weight: 700;
      color: var(--gold);
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
    }
    .combo-label {
      font-size: 11px;
      color: var(--gold);
      opacity: 0.8;
    }
    .lives-panel {
      position: absolute;
      bottom: 25px;
      left: 20px;
      display: flex;
      gap: 8px;
    }
    .life {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #ff4757, #c0392b);
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(255, 71, 87, 0.6);
      transition: all 0.3s ease;
    }
    .life.lost {
      background: #2a2a3a;
      box-shadow: none;
      transform: scale(0.8);
    }
    /* 飘分动画 */
    .floating-score {
      position: absolute;
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      pointer-events: none;
      animation: floatUp 0.8s ease-out forwards;
      z-index: 50;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
    }
    /* 连击提示 */
    .combo-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-size: clamp(32px, 8vw, 64px);
      font-weight: 900;
      color: var(--gold);
      text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
      pointer-events: none;
      opacity: 0;
      z-index: 60;
    }
    .combo-alert.show {
      animation: comboFlash 0.6s ease-out forwards;
    }
    @keyframes comboFlash {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    /* 开始/结束画面 */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 5, 8, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 30px;
      pointer-events: auto;
      z-index: 100;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .game-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(36px, 10vw, 72px);
      font-weight: 900;
      color: var(--text);
      text-align: center;
      line-height: 1.1;
    }
    .game-subtitle {
      font-size: clamp(14px, 3vw, 18px);
      color: var(--muted);
      text-align: center;
      max-width: 300px;
      line-height: 1.6;
    }
    .final-score {
      font-family: 'Orbitron', monospace;
      font-size: clamp(48px, 12vw, 96px);
      font-weight: 900;
      color: var(--gold);
      text-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
    }
    .start-btn {
      padding: 16px 48px;
      font-family: 'Orbitron', monospace;
      font-size: 18px;
      font-weight: 700;
      color: var(--bg-dark);
      background: linear-gradient(135deg, var(--accent), var(--accent-glow));
      border: none;
      border-radius: 50px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(255, 51, 102, 0.4);
      transition: all 0.3s ease;
    }
    .start-btn:active {
      transform: scale(0.95);
    }
    .high-score {
      font-size: 14px;
      color: var(--muted);
    }
    .high-score span {
      color: var(--gold);
      font-weight: 700;
    }
    .difficulty-badge {
      position: absolute;
      top: 80px;
      left: 20px;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .difficulty-badge.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
      <div class="score-panel">
        <span class="score-label">得分</span>
        <div class="score-display" id="scoreDisplay">0</div>
      </div>
      <div class="combo-display" id="comboDisplay">
        <div class="combo-text" id="comboText">x2</div>
        <div class="combo-label">连击</div>
      </div>
      <div class="lives-panel" id="livesPanel">
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
      </div>
      <div class="difficulty-badge" id="difficultyBadge"></div>
    </div>
    <div class="combo-alert" id="comboAlert">COMBO x5!</div>
    <!-- 开始画面 -->
    <div class="overlay" id="startOverlay">
      <h1 class="game-title">FRUIT<br>NINJA</h1>
      <p class="game-subtitle">滑动切割水果，避开炸弹<br>漏掉水果会失去生命</p>
      <button class="start-btn" id="startBtn">开始游戏</button>
      <p class="high-score">最高分: <span id="highScoreStart">0</span></p>
    </div>
    <!-- 结束画面 -->
    <div class="overlay hidden" id="gameOverOverlay">
      <h1 class="game-title">GAME OVER</h1>
      <div class="final-score" id="finalScore">0</div>
      <p class="high-score">最高分: <span id="highScoreEnd">0</span></p>
      <button class="start-btn" id="restartBtn">再来一次</button>
    </div>
  </div>
  <script>
    // ===== 音效系统 =====
    class SoundManager {
      constructor() {
        this.ctx = null;
        this.initialized = false;
      }
      init() {
        if (this.initialized) return;
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.initialized = true;
        } catch (e) {
          console.error("Web Audio API not supported");
        }
      }
      playSlice() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + Math.random() * 500;
        filter.Q.value = 1;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        noise.start(now); noise.stop(now + 0.1);
      }
      playBomb() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource(); noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.connect(gain); noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        osc.start(now); osc.stop(now + 0.5); noise.start(now); noise.stop(now + 0.5);
      }
      playMiss() {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(150, now + 0.2);
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(now); osc.stop(now + 0.2);
      }
      playCombo(level) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const baseFreq = 600 + level * 50;
        const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = baseFreq;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(now); osc.stop(now + 0.1);
      }
    }
    const soundManager = new SoundManager();
    // ===== 游戏配置 =====
    const CONFIG = {
      gravity: 0.25,             // 降低重力，使掉落更慢
      initialSpawnRate: 1800,    // 初始生成间隔稍微拉长
      minSpawnRate: 700,         // 最快生成间隔
      bombChance: 0.12,
      maxLives: 5,
      comboTime: 800,
      bladeTrailLength: 20,
    };
    // ===== 难度等级定义 =====
    const DIFFICULTY_LEVELS = [
      { name: '简单', color: '#27ae60', threshold: 0, maxFruits: 2, bombChanceMod: 0, speedMod: 0 },
      { name: '普通', color: '#f39c12', threshold: 30, maxFruits: 3, bombChanceMod: 0.05, speedMod: 0.5 },
      { name: '困难', color: '#e74c3c', threshold: 80, maxFruits: 4, bombChanceMod: 0.08, speedMod: 1 },
      { name: '噩梦', color: '#9b59b6', threshold: 150, maxFruits: 5, bombChanceMod: 0.10, speedMod: 1.5 },
      { name: '地狱', color: '#ff3366', threshold: 250, maxFruits: 7, bombChanceMod: 0.15, speedMod: 2 },
    ];
    // ===== 水果类型定义 =====
    const FRUIT_TYPES = [
      { name: 'apple', color: '#e74c3c', innerColor: '#f5d6ba', points: 1, radius: 32 },
      { name: 'orange', color: '#f39c12', innerColor: '#ffeaa7', points: 1, radius: 30 },
      { name: 'watermelon', color: '#27ae60', innerColor: '#ff6b6b', points: 2, radius: 40 },
      { name: 'lemon', color: '#f1c40f', innerColor: '#fffde7', points: 1, radius: 26 },
      { name: 'grape', color: '#9b59b6', innerColor: '#d4a5e8', points: 1, radius: 24 },
      { name: 'kiwi', color: '#795548', innerColor: '#a4d65e', points: 1, radius: 28 },
      { name: 'freeze', color: '#00bcd4', innerColor: '#e0f7fa', points: 3, radius: 34, special: 'freeze' },
    ];
    // ===== 游戏状态 =====
    let canvas, ctx;
    let gameWidth = 0;
    let gameHeight = 0;
    let dpr = 1;
    let gameState = 'menu';
    let score = 0;
    let highScore = parseInt(localStorage.getItem('fruitNinjaHighScore') || '0');
    let lives = CONFIG.maxLives;
    let combo = 0;
    let lastComboTime = 0;
    let lastSpawnTime = 0;
    let animationId = null;
    let currentDifficulty = DIFFICULTY_LEVELS[0];
    let slowMotionFactor = 1;
    let slowMotionTimeout = null;
    // ===== 游戏对象 =====
    let fruits = [];
    let slices = [];
    let particles = [];
    let bladeTrail = [];
    let isSlicing = false;
    let sliceStart = null;
    // ===== 初始化 =====
    function init() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      resizeCanvas();
      // 监听resize，处理移动端浏览器工具栏收起展开的问题
      window.addEventListener('resize', resizeCanvas);
      document.getElementById('highScoreStart').textContent = highScore;
      document.getElementById('highScoreEnd').textContent = highScore;
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);
      // 统一使用touch事件处理，兼容性更好
      canvas.addEventListener('mousedown', onSliceStart);
      canvas.addEventListener('mousemove', onSliceMove);
      canvas.addEventListener('mouseup', onSliceEnd);
      canvas.addEventListener('mouseleave', onSliceEnd);
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onSliceEnd);
      canvas.addEventListener('touchcancel', onSliceEnd); // 处理意外中断
      requestAnimationFrame(gameLoop);
    }
    function resizeCanvas() {
      // 使用window.innerHeight确保全屏
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      gameWidth = window.innerWidth;
      gameHeight = window.innerHeight;
      canvas.width = gameWidth * dpr;
      canvas.height = gameHeight * dpr;
      canvas.style.width = gameWidth + 'px';
      canvas.style.height = gameHeight + 'px';
      ctx.scale(dpr, dpr);
    }
    // ===== 游戏控制 =====
    function startGame() {
      soundManager.init(); 
      gameState = 'playing';
      score = 0;
      lives = CONFIG.maxLives;
      combo = 0;
      fruits = [];
      slices = [];
      particles = [];
      bladeTrail = [];
      lastSpawnTime = Date.now();
      currentDifficulty = DIFFICULTY_LEVELS[0];
      slowMotionFactor = 1;
      updateScoreDisplay();
      updateLivesDisplay();
      document.getElementById('startOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
    }
    function endGame() {
      gameState = 'gameover';
      slowMotionFactor = 1;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('fruitNinjaHighScore', highScore.toString());
      }
      document.getElementById('finalScore').textContent = score;
      document.getElementById('highScoreEnd').textContent = highScore;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
      document.getElementById('difficultyBadge').classList.remove('show');
    }
    // ===== 难度管理 =====
    function updateDifficulty() {
      let newDifficulty = DIFFICULTY_LEVELS[0];
      for (let i = DIFFICULTY_LEVELS.length - 1; i >= 0; i--) {
        if (score >= DIFFICULTY_LEVELS[i].threshold) {
          newDifficulty = DIFFICULTY_LEVELS[i];
          break;
        }
      }
      if (newDifficulty !== currentDifficulty) {
        currentDifficulty = newDifficulty;
        showDifficultyBadge();
      }
    }
    function showDifficultyBadge() {
      const badge = document.getElementById('difficultyBadge');
      badge.textContent = currentDifficulty.name;
      badge.style.backgroundColor = currentDifficulty.color;
      badge.style.color = '#fff';
      badge.classList.add('show');
    }
    function getSpawnRate() {
      const rateReduction = score * 4; // 稍微放缓难度增长
      return Math.max(CONFIG.minSpawnRate, CONFIG.initialSpawnRate - rateReduction);
    }
    // ===== 生成水果 (优化抛物线) =====
    function spawnFruit() {
      if (gameState !== 'playing') return;
      const now = Date.now();
      const spawnRate = getSpawnRate();
      if (now - lastSpawnTime < spawnRate) return;
      lastSpawnTime = now;
      const count = 1 + Math.floor(Math.random() * currentDifficulty.maxFruits);
      let bombCount = 0;
      const totalBombChance = CONFIG.bombChance + currentDifficulty.bombChanceMod;
      if (Math.random() < totalBombChance && score > 20) {
        bombCount = 1;
        if (currentDifficulty.name === '地狱' && Math.random() < 0.3) bombCount = 2;
      }
      const fruitCount = count - bombCount;
      const segmentWidth = gameWidth / count;
      const itemsToSpawn = [];
      for (let i = 0; i < fruitCount; i++) {
        const type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
        itemsToSpawn.push({ type: 'fruit', data: type });
      }
      for (let i = 0; i < bombCount; i++) itemsToSpawn.push({ type: 'bomb', data: null });
      shuffleArray(itemsToSpawn);
      itemsToSpawn.forEach((item, index) => {
        const baseX = (segmentWidth * index) + (segmentWidth / 2);
        const randomOffsetX = (Math.random() - 0.5) * segmentWidth * 0.6;
        const x = Math.max(50, Math.min(gameWidth - 50, baseX + randomOffsetX));
        const y = gameHeight + 60; // 稍微从更下方开始，保证初始不可见
        // 优化水平速度：让水果向屏幕中心靠拢，避免飞出边界
        const centerDist = (x - gameWidth / 2) / (gameWidth / 2);
        const vx = centerDist * -1.5 + (Math.random() - 0.5) * 1.5; 
        // 核心优化：垂直速度计算
        // 目标：飞到屏幕高度的 40% ~ 55% 位置
        // 使用运动学公式：v = sqrt(2 * g * h)，其中 h 是我们想要的高度
        const targetHeight = gameHeight * (0.4 + Math.random() * 0.15); // 屏幕中上部
        let baseVy = Math.sqrt(2 * CONFIG.gravity * targetHeight);
        // 加上难度修正，让后期稍微快一点点，但保持可控
        baseVy += currentDifficulty.speedMod; 
        const vy = -baseVy; // 负号代表向上
        if (item.type === 'bomb') {
          fruits.push({
            x, y, vx, vy, radius: 30, rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.1, isBomb: true, sliced: false, points: 0
          });
        } else {
          const typeData = item.data;
          fruits.push({
            x, y, vx, vy, radius: typeData.radius, color: typeData.color,
            innerColor: typeData.innerColor, points: typeData.points,
            rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.15,
            type: typeData, isBomb: false, sliced: false
          });
        }
      });
    }
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    // ===== 输入处理 =====
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function onSliceStart(e) {
      if (gameState !== 'playing') return;
      isSlicing = true;
      sliceStart = getPos(e);
      bladeTrail = [sliceStart];
    }
    function onSliceMove(e) {
      if (!isSlicing || gameState !== 'playing') return;
      const pos = getPos(e);
      bladeTrail.push(pos);
      if (bladeTrail.length > CONFIG.bladeTrailLength) bladeTrail.shift();
      checkSliceCollisions(pos);
    }
    function onSliceEnd() {
      isSlicing = false;
      sliceStart = null;
      setTimeout(() => { bladeTrail = []; }, 100);
    }
    function onTouchStart(e) {
      e.preventDefault();
      if (gameState !== 'playing') return;
      const touch = e.touches[0];
      isSlicing = true;
      sliceStart = getPos(touch);
      bladeTrail = [sliceStart];
    }
    function onTouchMove(e) {
      e.preventDefault();
      if (!isSlicing || gameState !== 'playing') return;
      const touch = e.touches[0];
      const pos = getPos(touch);
      bladeTrail.push(pos);
      if (bladeTrail.length > CONFIG.bladeTrailLength) bladeTrail.shift();
      checkSliceCollisions(pos);
    }
    // ===== 碰撞检测 =====
    function checkSliceCollisions(pos) {
      if (bladeTrail.length < 2) return;
      const prev = bladeTrail[bladeTrail.length - 2];
      const curr = pos;
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        if (fruit.sliced) continue;
        if (lineCircleCollision(prev, curr, fruit)) {
          if (fruit.isBomb) {
            soundManager.playBomb();
            createExplosion(fruit);
            fruits.splice(i, 1);
            endGame();
            return;
          } else {
            sliceFruit(fruit, i, curr);
          }
        }
      }
    }
    function lineCircleCollision(p1, p2, circle) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const fx = p1.x - circle.x;
      const fy = p1.y - circle.y;
      const a = dx * dx + dy * dy;
      if (a === 0) return false; // 避免除以0
      const b = 2 * (fx * dx + fy * dy);
      const c = fx * fx + fy * fy - circle.radius * circle.radius;
      let discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return false;
      discriminant = Math.sqrt(discriminant);
      const t1 = (-b - discriminant) / (2 * a);
      const t2 = (-b + discriminant) / (2 * a);
      return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
    }
    // ===== 水果切割 =====
    function sliceFruit(fruit, index, slicePos) {
      fruit.sliced = true;
      soundManager.playSlice();
      if (fruit.type && fruit.type.special === 'freeze') activateSlowMotion();
      const angle = Math.atan2(
        bladeTrail[bladeTrail.length - 1].y - bladeTrail[0].y,
        bladeTrail[bladeTrail.length - 1].x - bladeTrail[0].x
      );
      slices.push(createSlice(fruit, angle, -1));
      slices.push(createSlice(fruit, angle, 1));
      createJuiceParticles(fruit, slicePos);
      updateCombo();
      const pointsGained = fruit.points * combo;
      score += pointsGained;
      showFloatingScore(slicePos.x, slicePos.y, pointsGained, combo > 1);
      updateScoreDisplay();
      updateDifficulty();
      fruits.splice(index, 1);
    }
    function activateSlowMotion() {
      slowMotionFactor = 0.5;
      if (slowMotionTimeout) clearTimeout(slowMotionTimeout);
      slowMotionTimeout = setTimeout(() => { slowMotionFactor = 1; }, 2000);
    }
    function showFloatingScore(x, y, points, isCombo) {
      const container = document.getElementById('gameContainer');
      const floatingDiv = document.createElement('div');
      floatingDiv.className = 'floating-score';
      floatingDiv.textContent = '+' + points;
      floatingDiv.style.left = x + 'px';
      floatingDiv.style.top = y + 'px';
      if (isCombo) {
        floatingDiv.style.color = '#ffd700';
        floatingDiv.style.fontSize = '24px';
        floatingDiv.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
      } else {
        floatingDiv.style.color = '#ffffff';
        floatingDiv.style.fontSize = '18px';
      }
      container.appendChild(floatingDiv);
      setTimeout(() => { floatingDiv.remove(); }, 800);
    }
    function createSlice(fruit, angle, side) {
      return {
        x: fruit.x, y: fruit.y,
        vx: fruit.vx + side * Math.cos(angle + Math.PI/2) * 8,
        vy: fruit.vy + side * Math.sin(angle + Math.PI/2) * 8 - 5,
        radius: fruit.radius, color: fruit.color, innerColor: fruit.innerColor,
        angle: angle, rotation: fruit.rotation,
        rotationSpeed: fruit.rotationSpeed + side * 0.1, alpha: 1,
        type: fruit.type, side: side, isSpecial: fruit.type && fruit.type.special
      };
    }
    // ===== 粒子效果 =====
    function createJuiceParticles(fruit, pos) {
      const particleCount = 15 + Math.floor(fruit.radius / 3);
      for (let i = 0; i < particleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 6;
        particles.push({
          x: pos.x, y: pos.y,
          vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2,
          radius: 2 + Math.random() * 4, color: fruit.innerColor, alpha: 1, life: 1
        });
      }
    }
    function createExplosion(bomb) {
      for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 5 + Math.random() * 15;
        particles.push({
          x: bomb.x, y: bomb.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
          radius: 3 + Math.random() * 8, color: i % 2 === 0 ? '#ff3366' : '#ffcc00',
          alpha: 1, life: 1
        });
      }
    }
    function createMissParticles(x, y) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x, y: y, vx: (Math.random() - 0.5) * 4, vy: -Math.random() * 3,
          radius: 3 + Math.random() * 3, color: '#ff4757', alpha: 1, life: 1
        });
      }
    }
    // ===== 连击系统 =====
    function updateCombo() {
      const now = Date.now();
      if (now - lastComboTime < CONFIG.comboTime) {
        combo = Math.min(combo + 1, 10);
      } else {
        combo = 1;
      }
      lastComboTime = now;
      if (combo > 1) {
        soundManager.playCombo(combo);
        const comboDisplay = document.getElementById('comboDisplay');
        const comboText = document.getElementById('comboText');
        comboDisplay.classList.add('active');
        comboText.textContent = 'x' + combo;
        comboText.style.transform = 'scale(1.2)';
        setTimeout(() => { comboText.style.transform = 'scale(1)'; }, 100);
        if (combo >= 5 && combo % 5 === 0) showComboAlert(combo);
      }
      clearTimeout(window.comboResetTimer);
      window.comboResetTimer = setTimeout(() => {
        document.getElementById('comboDisplay').classList.remove('active');
        combo = 0;
      }, CONFIG.comboTime * 2);
    }
    function showComboAlert(comboCount) {
      const alert = document.getElementById('comboAlert');
      alert.textContent = 'COMBO x' + comboCount + '!';
      alert.classList.remove('show');
      void alert.offsetWidth;
      alert.classList.add('show');
    }
    // ===== UI更新 =====
    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById('scoreDisplay');
      scoreDisplay.textContent = score;
      scoreDisplay.style.transform = 'scale(1.1)';
      setTimeout(() => { scoreDisplay.style.transform = 'scale(1)'; }, 100);
    }
    function updateLivesDisplay() {
      const livesPanel = document.getElementById('livesPanel');
      const lifeElements = livesPanel.querySelectorAll('.life');
      lifeElements.forEach((el, i) => {
        if (i < lives) el.classList.remove('lost');
        else el.classList.add('lost');
      });
    }
    // ===== 更新逻辑 =====
    function update() {
      if (gameState !== 'playing') return;
      const dt = slowMotionFactor;
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        fruit.vy += CONFIG.gravity * dt;
        fruit.x += fruit.vx * dt;
        fruit.y += fruit.vy * dt;
        fruit.rotation += fruit.rotationSpeed * dt;
        if (fruit.y > gameHeight + 100 && !fruit.sliced && !fruit.isBomb) {
          soundManager.playMiss();
          createMissParticles(fruit.x, gameHeight);
          fruits.splice(i, 1);
          lives--;
          updateLivesDisplay();
          if (lives <= 0) endGame();
        }
        // 清理飞出屏幕太远的对象
        if (fruit.y > gameHeight + 200 || fruit.y < -gameHeight) fruits.splice(i, 1);
      }
      for (let i = slices.length - 1; i >= 0; i--) {
        const slice = slices[i];
        slice.vy += CONFIG.gravity * dt;
        slice.x += slice.vx * dt;
        slice.y += slice.vy * dt;
        slice.rotation += slice.rotationSpeed * dt;
        slice.alpha -= 0.015 * dt;
        if (slice.alpha <= 0 || slice.y > gameHeight + 100) slices.splice(i, 1);
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.vy += 0.2 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= 0.02 * dt;
        p.alpha = p.life;
        if (p.life <= 0) particles.splice(i, 1);
      }
      spawnFruit();
    }
    // ===== 渲染 =====
    function render() {
      ctx.clearRect(0, 0, gameWidth, gameHeight);
      drawBackground();
      if (slowMotionFactor < 1) {
        ctx.fillStyle = 'rgba(0, 188, 212, 0.05)';
        ctx.fillRect(0, 0, gameWidth, gameHeight);
      }
      drawParticles();
      drawFruits();
      drawSlices();
      drawBladeTrail();
    }
    function drawBackground() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let x = 0; x < gameWidth; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, gameHeight); ctx.stroke(); }
      for (let y = 0; y < gameHeight; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(gameWidth, y); ctx.stroke(); }
    }
    function drawFruits() {
      fruits.forEach(fruit => {
        if (fruit.sliced) return;
        ctx.save();
        ctx.translate(fruit.x, fruit.y);
        ctx.rotate(fruit.rotation);
        if (fruit.isBomb) drawBomb(fruit);
        else drawFruit(fruit);
        ctx.restore();
      });
    }
    function drawFruit(fruit) {
      const r = fruit.radius;
      ctx.shadowColor = fruit.color; ctx.shadowBlur = 20;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = fruit.color; ctx.fill();
      ctx.shadowBlur = 0;
      const gradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, 0, 0, r);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
      gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
      if (fruit.type && fruit.type.special === 'freeze') {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, r + 5, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            ctx.beginPath(); ctx.arc(Math.cos(angle) * (r - 10), Math.sin(angle) * (r - 10), 3, 0, Math.PI * 2); ctx.fill();
        }
      } else {
        ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.ellipse(0, -r - 5, 4, 8, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.ellipse(5, -r - 2, 6, 4, Math.PI / 4, 0, Math.PI * 2); ctx.fill();
      }
    }
    function drawBomb(bomb) {
      const r = bomb.radius;
      ctx.shadowColor = '#ff3366'; ctx.shadowBlur = 30;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = '#1a1a2e'; ctx.fill();
      ctx.shadowBlur = 0;
      const gradient = ctx.createLinearGradient(-r, -r, r, r);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)'); gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
      ctx.strokeStyle = '#8b7355'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -r); ctx.quadraticCurveTo(10, -r - 15, 5, -r - 20); ctx.stroke();
      const time = Date.now() / 100;
      ctx.fillStyle = `hsl(${30 + Math.sin(time) * 20}, 100%, 60%)`;
      ctx.beginPath(); ctx.arc(5 + Math.sin(time * 2) * 2, -r - 20 + Math.cos(time) * 2, 5 + Math.sin(time) * 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff3366'; ctx.font = `bold ${r * 0.8}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('X', 0, 0);
    }
    function drawSlices() {
      slices.forEach(slice => {
        ctx.save(); ctx.globalAlpha = slice.alpha; ctx.translate(slice.x, slice.y); ctx.rotate(slice.rotation);
        const r = slice.radius;
        ctx.beginPath();
        if (slice.side < 0) ctx.arc(0, 0, r, slice.angle + Math.PI/2, slice.angle - Math.PI/2);
        else ctx.arc(0, 0, r, slice.angle - Math.PI/2, slice.angle + Math.PI/2);
        ctx.closePath(); ctx.fillStyle = slice.color; ctx.fill();
        ctx.beginPath();
        if (slice.side < 0) ctx.arc(0, 0, r * 0.85, slice.angle + Math.PI/2, slice.angle - Math.PI/2);
        else ctx.arc(0, 0, r * 0.85, slice.angle - Math.PI/2, slice.angle + Math.PI/2);
        ctx.closePath(); ctx.fillStyle = slice.innerColor; ctx.fill();
        ctx.restore();
      });
    }
    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.5, p.radius * p.alpha), 0, Math.PI * 2); ctx.fill();
      });
      ctx.globalAlpha = 1;
    }
    function drawBladeTrail() {
      if (bladeTrail.length < 2) return;
      ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 20;
      for (let i = 1; i < bladeTrail.length; i++) {
        const prev = bladeTrail[i - 1]; const curr = bladeTrail[i]; const progress = i / bladeTrail.length;
        ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y);
        const gradient = ctx.createLinearGradient(prev.x, prev.y, curr.x, curr.y);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${progress * 0.3})`); gradient.addColorStop(1, `rgba(255, 255, 255, ${progress})`);
        ctx.strokeStyle = gradient; ctx.lineWidth = progress * 12; ctx.stroke();
      }
      for (let i = 1; i < bladeTrail.length; i++) {
        const prev = bladeTrail[i - 1]; const curr = bladeTrail[i]; const progress = i / bladeTrail.length;
        ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${progress})`; ctx.lineWidth = progress * 3; ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    // ===== 游戏循环 =====
    function gameLoop() {
      update();
      render();
      animationId = requestAnimationFrame(gameLoop);
    }
    // 启动游戏
    init();
  </script>
</body>
</html>
