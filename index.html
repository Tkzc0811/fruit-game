<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>水果忍者大师版</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Noto+Sans+SC:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-dark: #0a0a12;
        --bg-glow: #1a0a2e;
        --accent: #ff3366;
        --accent-glow: #ff6b9d;
        --gold: #ffd700;
        --text: #f0f0f5;
        --muted: #6b6b8a;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        touch-action: none;
        user-select: none;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: var(--bg-dark);
        font-family: "Noto Sans SC", sans-serif;
      }
      #gameContainer {
        position: relative;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at 50% 100%,
          #1a0a2e 0%,
          #0a0a12 50%,
          #050508 100%
        );
      }
      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }
      /* UI层 */
      .ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .score-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .score-display {
        font-family: "Orbitron", monospace;
        font-size: clamp(28px, 6vw, 48px);
        font-weight: 900;
        color: var(--text);
        text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
        transition: transform 0.1s ease;
      }
      .score-label {
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 2px;
      }
      .combo-display {
        position: absolute;
        top: 20px;
        right: 20px;
        text-align: right;
        opacity: 0;
        transform: scale(0.8);
        transition: all 0.2s ease;
      }
      .combo-display.active {
        opacity: 1;
        transform: scale(1);
      }
      .combo-text {
        font-family: "Orbitron", monospace;
        font-size: clamp(24px, 5vw, 40px);
        font-weight: 700;
        color: var(--gold);
        text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      }
      .combo-label {
        font-size: 11px;
        color: var(--gold);
        opacity: 0.8;
      }
      .lives-panel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 8px;
      }
      .life {
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, #ff4757, #c0392b);
        border-radius: 50%;
        box-shadow: 0 0 15px rgba(255, 71, 87, 0.6);
        transition: all 0.3s ease;
      }
      .life.lost {
        background: #2a2a3a;
        box-shadow: none;
        transform: scale(0.8);
      }
      /* 飘分动画 */
      .floating-score {
        position: absolute;
        font-family: "Orbitron", monospace;
        font-weight: 900;
        pointer-events: none;
        animation: floatUp 0.8s ease-out forwards;
        z-index: 50;
      }
      @keyframes floatUp {
        0% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateY(-60px) scale(1.3);
        }
      }
      /* 连击提示 */
      .combo-alert {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: "Orbitron", monospace;
        font-size: clamp(32px, 8vw, 64px);
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
        pointer-events: none;
        opacity: 0;
        z-index: 60;
      }
      .combo-alert.show {
        animation: comboFlash 0.6s ease-out forwards;
      }
      @keyframes comboFlash {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        30% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1.5);
        }
      }
      /* 开始/结束画面 */
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(5, 5, 8, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 30px;
        pointer-events: auto;
        z-index: 100;
        opacity: 1;
        transition: opacity 0.5s ease;
      }
      .overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .game-title {
        font-family: "Orbitron", monospace;
        font-size: clamp(36px, 10vw, 72px);
        font-weight: 900;
        color: var(--text);
        text-align: center;
        line-height: 1.1;
      }
      .game-subtitle {
        font-size: clamp(14px, 3vw, 18px);
        color: var(--muted);
        text-align: center;
        max-width: 300px;
        line-height: 1.6;
      }
      .final-score {
        font-family: "Orbitron", monospace;
        font-size: clamp(48px, 12vw, 96px);
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
      }
      .start-btn {
        padding: 16px 48px;
        font-family: "Orbitron", monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--bg-dark);
        background: linear-gradient(135deg, var(--accent), var(--accent-glow));
        border: none;
        border-radius: 50px;
        cursor: pointer;
        pointer-events: auto;
        box-shadow: 0 10px 40px rgba(255, 51, 102, 0.4);
        transition: all 0.3s ease;
      }
      .start-btn:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 15px 50px rgba(255, 51, 102, 0.6);
      }
      .start-btn:active {
        transform: translateY(0) scale(0.98);
      }
      .high-score {
        font-size: 14px;
        color: var(--muted);
      }
      .high-score span {
        color: var(--gold);
        font-weight: 700;
      }
      .difficulty-badge {
        position: absolute;
        top: 80px;
        left: 20px;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        opacity: 0;
        transition: all 0.3s ease;
      }
      .difficulty-badge.show {
        opacity: 1;
      }
      @media (max-width: 480px) {
        .score-panel {
          top: 15px;
          left: 15px;
        }
        .combo-display {
          top: 15px;
          right: 15px;
        }
        .lives-panel {
          bottom: 15px;
          left: 15px;
        }
        .life {
          width: 22px;
          height: 22px;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>
      <div class="ui-layer">
        <div class="score-panel">
          <span class="score-label">得分</span>
          <div class="score-display" id="scoreDisplay">0</div>
        </div>
        <div class="combo-display" id="comboDisplay">
          <div class="combo-text" id="comboText">x2</div>
          <div class="combo-label">连击</div>
        </div>
        <div class="lives-panel" id="livesPanel">
          <div class="life"></div>
          <div class="life"></div>
          <div class="life"></div>
          <div class="life"></div>
          <div class="life"></div>
        </div>
        <div class="difficulty-badge" id="difficultyBadge"></div>
      </div>
      <div class="combo-alert" id="comboAlert">COMBO x5!</div>
      <!-- 开始画面 -->
      <div class="overlay" id="startOverlay">
        <h1 class="game-title">FRUIT<br />NINJA</h1>
        <p class="game-subtitle">
          一次切多个水果得分更高<br />小心混在其中的炸弹
        </p>
        <button class="start-btn" id="startBtn">开始游戏</button>
        <p class="high-score">最高分: <span id="highScoreStart">0</span></p>
      </div>
      <!-- 结束画面 -->
      <div class="overlay hidden" id="gameOverOverlay">
        <h1 class="game-title">GAME OVER</h1>
        <div class="final-score" id="finalScore">0</div>
        <p class="high-score">最高分: <span id="highScoreEnd">0</span></p>
        <button class="start-btn" id="restartBtn">再来一次</button>
      </div>
    </div>
    <script>
      // ===== 游戏配置 =====
      const CONFIG = {
        gravity: 0.35,
        initialSpawnRate: 1600, // 初始生成间隔
        minSpawnRate: 600, // 最快生成间隔
        bombChance: 0.12, // 基础炸弹概率
        maxLives: 5,
        comboTime: 800,
        bladeTrailLength: 20,
      };
      // ===== 难度等级定义 =====
      const DIFFICULTY_LEVELS = [
        {
          name: "简单",
          color: "#27ae60",
          threshold: 0,
          maxFruits: 2,
          bombChanceMod: 0,
        },
        {
          name: "普通",
          color: "#f39c12",
          threshold: 30,
          maxFruits: 3,
          bombChanceMod: 0.05,
        },
        {
          name: "困难",
          color: "#e74c3c",
          threshold: 80,
          maxFruits: 4,
          bombChanceMod: 0.08,
        },
        {
          name: "噩梦",
          color: "#9b59b6",
          threshold: 150,
          maxFruits: 5,
          bombChanceMod: 0.1,
        },
        {
          name: "地狱",
          color: "#ff3366",
          threshold: 250,
          maxFruits: 7,
          bombChanceMod: 0.15,
        },
      ];
      // ===== 水果类型定义 =====
      const FRUIT_TYPES = [
        {
          name: "apple",
          color: "#e74c3c",
          innerColor: "#f5d6ba",
          points: 1,
          radius: 35,
        },
        {
          name: "orange",
          color: "#f39c12",
          innerColor: "#ffeaa7",
          points: 1,
          radius: 32,
        },
        {
          name: "watermelon",
          color: "#27ae60",
          innerColor: "#ff6b6b",
          points: 2,
          radius: 45,
        },
        {
          name: "lemon",
          color: "#f1c40f",
          innerColor: "#fffde7",
          points: 1,
          radius: 28,
        },
        {
          name: "grape",
          color: "#9b59b6",
          innerColor: "#d4a5e8",
          points: 1,
          radius: 25,
        },
        {
          name: "kiwi",
          color: "#795548",
          innerColor: "#a4d65e",
          points: 1,
          radius: 30,
        },
        {
          name: "freeze",
          color: "#00bcd4",
          innerColor: "#e0f7fa",
          points: 3,
          radius: 38,
          special: "freeze",
        },
      ];
      // ===== 游戏状态 =====
      let canvas, ctx;
      let gameWidth = 0;
      let gameHeight = 0;
      let dpr = 1;
      let gameState = "menu";
      let score = 0;
      let highScore = parseInt(
        localStorage.getItem("fruitNinjaHighScore") || "0"
      );
      let lives = CONFIG.maxLives;
      let combo = 0;
      let lastComboTime = 0;
      let lastSpawnTime = 0;
      let animationId = null;
      let currentDifficulty = DIFFICULTY_LEVELS[0];
      let slowMotionFactor = 1;
      let slowMotionTimeout = null;
      // ===== 游戏对象 =====
      let fruits = [];
      let slices = [];
      let particles = [];
      let bladeTrail = [];
      let isSlicing = false;
      let sliceStart = null;
      // ===== 初始化 =====
      function init() {
        canvas = document.getElementById("gameCanvas");
        ctx = canvas.getContext("2d");
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
        document.getElementById("highScoreStart").textContent = highScore;
        document.getElementById("highScoreEnd").textContent = highScore;
        const startBtn = document.getElementById("startBtn");
        const restartBtn = document.getElementById("restartBtn");
        startBtn.addEventListener("click", startGame);
        restartBtn.addEventListener("click", startGame);
        canvas.addEventListener("mousedown", onSliceStart);
        canvas.addEventListener("mousemove", onSliceMove);
        canvas.addEventListener("mouseup", onSliceEnd);
        canvas.addEventListener("mouseleave", onSliceEnd);
        canvas.addEventListener("touchstart", onTouchStart, { passive: false });
        canvas.addEventListener("touchmove", onTouchMove, { passive: false });
        canvas.addEventListener("touchend", onSliceEnd);
        requestAnimationFrame(gameLoop);
      }
      function resizeCanvas() {
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        gameWidth = window.innerWidth;
        gameHeight = window.innerHeight;
        canvas.width = gameWidth * dpr;
        canvas.height = gameHeight * dpr;
        canvas.style.width = gameWidth + "px";
        canvas.style.height = gameHeight + "px";
        ctx.scale(dpr, dpr);
      }
      // ===== 游戏控制 =====
      function startGame() {
        gameState = "playing";
        score = 0;
        lives = CONFIG.maxLives;
        combo = 0;
        fruits = [];
        slices = [];
        particles = [];
        bladeTrail = [];
        lastSpawnTime = Date.now();
        currentDifficulty = DIFFICULTY_LEVELS[0];
        slowMotionFactor = 1;
        updateScoreDisplay();
        updateLivesDisplay();
        document.getElementById("startOverlay").classList.add("hidden");
        document.getElementById("gameOverOverlay").classList.add("hidden");
      }
      function endGame() {
        gameState = "gameover";
        slowMotionFactor = 1;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("fruitNinjaHighScore", highScore.toString());
        }
        document.getElementById("finalScore").textContent = score;
        document.getElementById("highScoreEnd").textContent = highScore;
        document.getElementById("gameOverOverlay").classList.remove("hidden");
        document.getElementById("difficultyBadge").classList.remove("show");
      }
      // ===== 难度管理 =====
      function updateDifficulty() {
        let newDifficulty = DIFFICULTY_LEVELS[0];
        for (let i = DIFFICULTY_LEVELS.length - 1; i >= 0; i--) {
          if (score >= DIFFICULTY_LEVELS[i].threshold) {
            newDifficulty = DIFFICULTY_LEVELS[i];
            break;
          }
        }
        if (newDifficulty !== currentDifficulty) {
          currentDifficulty = newDifficulty;
          showDifficultyBadge();
        }
      }
      function showDifficultyBadge() {
        const badge = document.getElementById("difficultyBadge");
        badge.textContent = currentDifficulty.name;
        badge.style.backgroundColor = currentDifficulty.color;
        badge.style.color = "#fff";
        badge.classList.add("show");
      }
      function getSpawnRate() {
        const rateReduction = score * 5;
        return Math.max(
          CONFIG.minSpawnRate,
          CONFIG.initialSpawnRate - rateReduction
        );
      }
      // ===== 生成水果 (核心修改：多水果波次) =====
      function spawnFruit() {
        if (gameState !== "playing") return;
        const now = Date.now();
        const spawnRate = getSpawnRate();
        if (now - lastSpawnTime < spawnRate) return;
        lastSpawnTime = now;
        // 1. 确定本次生成的总数量 (基于当前难度)
        const count =
          1 + Math.floor(Math.random() * currentDifficulty.maxFruits);
        // 2. 确定是否包含炸弹 (概率基于难度)
        // 随机决定这波里有几个炸弹 (通常是0或1个，高难度下可能是1-2个)
        let bombCount = 0;
        const totalBombChance =
          CONFIG.bombChance + currentDifficulty.bombChanceMod;
        // 简单逻辑：如果随机值小于炸弹概率，则这波至少有一个炸弹
        if (Math.random() < totalBombChance && score > 20) {
          bombCount = 1;
          // 地狱难度有几率出双炸弹
          if (currentDifficulty.name === "地狱" && Math.random() < 0.3) {
            bombCount = 2;
          }
        }
        const fruitCount = count - bombCount;
        // 3. 计算水平分布，防止重叠
        // 将屏幕宽度分为 count 个区域
        const segmentWidth = gameWidth / count;
        // 生成物品的临时数组，用于排序
        const itemsToSpawn = [];
        // 添加水果
        for (let i = 0; i < fruitCount; i++) {
          const type =
            FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
          itemsToSpawn.push({
            type: "fruit",
            data: type,
          });
        }
        // 添加炸弹
        for (let i = 0; i < bombCount; i++) {
          itemsToSpawn.push({
            type: "bomb",
            data: null,
          });
        }
        // 打乱顺序，让炸弹随机出现在不同位置
        shuffleArray(itemsToSpawn);
        // 4. 批量生成实体
        itemsToSpawn.forEach((item, index) => {
          // 基础 X 位置：位于各自的分段区域内，稍微随机偏移
          // 确保水果不会太靠边
          const baseX = segmentWidth * index + segmentWidth / 2;
          const randomOffsetX = (Math.random() - 0.5) * segmentWidth * 0.6; // 60%的范围内浮动
          const x = Math.max(
            50,
            Math.min(gameWidth - 50, baseX + randomOffsetX)
          );
          // 基础 Y 位置：都在屏幕底部以下
          const y = gameHeight + 50 + Math.random() * 30;
          // 速度：给予轻微的水平差异，让轨迹分散
          // 左边的水果稍微向右飞，右边的稍微向左飞，更有"喷射"感
          const centerDist = (x - gameWidth / 2) / (gameWidth / 2); // -1 到 1
          const vx = centerDist * -2 + (Math.random() - 0.5) * 2;
          // 垂直速度：根据难度调整
          const vy =
            -14 - Math.random() * 6 - currentDifficulty.threshold / 100;
          if (item.type === "bomb") {
            fruits.push({
              x: x,
              y: y,
              vx: vx,
              vy: vy,
              radius: 30,
              rotation: 0,
              rotationSpeed: (Math.random() - 0.5) * 0.1,
              isBomb: true,
              sliced: false,
              points: 0,
            });
          } else {
            const typeData = item.data;
            fruits.push({
              x: x,
              y: y,
              vx: vx,
              vy: vy,
              radius: typeData.radius,
              color: typeData.color,
              innerColor: typeData.innerColor,
              points: typeData.points,
              rotation: Math.random() * Math.PI * 2,
              rotationSpeed: (Math.random() - 0.5) * 0.15,
              type: typeData,
              isBomb: false,
              sliced: false,
            });
          }
        });
      }
      // 数组随机打乱算法
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      // ===== 输入处理 =====
      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }
      function onSliceStart(e) {
        if (gameState !== "playing") return;
        isSlicing = true;
        sliceStart = getPos(e);
        bladeTrail = [sliceStart];
      }
      function onSliceMove(e) {
        if (!isSlicing || gameState !== "playing") return;
        const pos = getPos(e);
        bladeTrail.push(pos);
        if (bladeTrail.length > CONFIG.bladeTrailLength) {
          bladeTrail.shift();
        }
        checkSliceCollisions(pos);
      }
      function onSliceEnd() {
        isSlicing = false;
        sliceStart = null;
        setTimeout(() => {
          bladeTrail = [];
        }, 100);
      }
      function onTouchStart(e) {
        e.preventDefault();
        if (gameState !== "playing") return;
        const touch = e.touches[0];
        isSlicing = true;
        sliceStart = getPos(touch);
        bladeTrail = [sliceStart];
      }
      function onTouchMove(e) {
        e.preventDefault();
        if (!isSlicing || gameState !== "playing") return;
        const touch = e.touches[0];
        const pos = getPos(touch);
        bladeTrail.push(pos);
        if (bladeTrail.length > CONFIG.bladeTrailLength) {
          bladeTrail.shift();
        }
        checkSliceCollisions(pos);
      }
      // ===== 碰撞检测 =====
      function checkSliceCollisions(pos) {
        if (bladeTrail.length < 2) return;
        const prev = bladeTrail[bladeTrail.length - 2];
        const curr = pos;
        // 倒序遍历，方便删除
        for (let i = fruits.length - 1; i >= 0; i--) {
          const fruit = fruits[i];
          if (fruit.sliced) continue;
          if (lineCircleCollision(prev, curr, fruit)) {
            if (fruit.isBomb) {
              createExplosion(fruit);
              fruits.splice(i, 1);
              endGame();
              return;
            } else {
              sliceFruit(fruit, i, curr);
            }
          }
        }
      }
      function lineCircleCollision(p1, p2, circle) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const fx = p1.x - circle.x;
        const fy = p1.y - circle.y;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - circle.radius * circle.radius;
        let discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return false;
        discriminant = Math.sqrt(discriminant);
        const t1 = (-b - discriminant) / (2 * a);
        const t2 = (-b + discriminant) / (2 * a);
        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
      }
      // ===== 水果切割 =====
      function sliceFruit(fruit, index, slicePos) {
        fruit.sliced = true;
        if (fruit.type && fruit.type.special === "freeze") {
          activateSlowMotion();
        }
        const angle = Math.atan2(
          bladeTrail[bladeTrail.length - 1].y - bladeTrail[0].y,
          bladeTrail[bladeTrail.length - 1].x - bladeTrail[0].x
        );
        const leftSlice = createSlice(fruit, angle, -1);
        const rightSlice = createSlice(fruit, angle, 1);
        slices.push(leftSlice, rightSlice);
        createJuiceParticles(fruit, slicePos);
        updateCombo();
        const pointsGained = fruit.points * combo;
        score += pointsGained;
        showFloatingScore(slicePos.x, slicePos.y, pointsGained, combo > 1);
        updateScoreDisplay();
        updateDifficulty();
        fruits.splice(index, 1);
      }
      function activateSlowMotion() {
        slowMotionFactor = 0.5;
        if (slowMotionTimeout) clearTimeout(slowMotionTimeout);
        slowMotionTimeout = setTimeout(() => {
          slowMotionFactor = 1;
        }, 2000);
      }
      function showFloatingScore(x, y, points, isCombo) {
        const container = document.getElementById("gameContainer");
        const floatingDiv = document.createElement("div");
        floatingDiv.className = "floating-score";
        floatingDiv.textContent = "+" + points;
        floatingDiv.style.left = x + "px";
        floatingDiv.style.top = y + "px";
        if (isCombo) {
          floatingDiv.style.color = "#ffd700";
          floatingDiv.style.fontSize = "24px";
          floatingDiv.style.textShadow = "0 0 10px rgba(255, 215, 0, 0.8)";
        } else {
          floatingDiv.style.color = "#ffffff";
          floatingDiv.style.fontSize = "18px";
        }
        container.appendChild(floatingDiv);
        setTimeout(() => {
          floatingDiv.remove();
        }, 800);
      }
      function createSlice(fruit, angle, side) {
        return {
          x: fruit.x,
          y: fruit.y,
          vx: fruit.vx + side * Math.cos(angle + Math.PI / 2) * 8,
          vy: fruit.vy + side * Math.sin(angle + Math.PI / 2) * 8 - 5,
          radius: fruit.radius,
          color: fruit.color,
          innerColor: fruit.innerColor,
          angle: angle,
          rotation: fruit.rotation,
          rotationSpeed: fruit.rotationSpeed + side * 0.1,
          alpha: 1,
          type: fruit.type,
          side: side,
          isSpecial: fruit.type && fruit.type.special,
        };
      }
      // ===== 粒子效果 =====
      function createJuiceParticles(fruit, pos) {
        const particleCount = 15 + Math.floor(fruit.radius / 3);
        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 6;
          particles.push({
            x: pos.x,
            y: pos.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            radius: 2 + Math.random() * 4,
            color: fruit.innerColor,
            alpha: 1,
            life: 1,
          });
        }
      }
      function createExplosion(bomb) {
        for (let i = 0; i < 60; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 5 + Math.random() * 15;
          particles.push({
            x: bomb.x,
            y: bomb.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 3 + Math.random() * 8,
            color: i % 2 === 0 ? "#ff3366" : "#ffcc00",
            alpha: 1,
            life: 1,
          });
        }
      }
      function createMissParticles(x, y) {
        for (let i = 0; i < 10; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 3,
            radius: 3 + Math.random() * 3,
            color: "#ff4757",
            alpha: 1,
            life: 1,
          });
        }
      }
      // ===== 连击系统 =====
      function updateCombo() {
        const now = Date.now();
        if (now - lastComboTime < CONFIG.comboTime) {
          combo = Math.min(combo + 1, 10);
        } else {
          combo = 1;
        }
        lastComboTime = now;
        const comboDisplay = document.getElementById("comboDisplay");
        const comboText = document.getElementById("comboText");
        if (combo > 1) {
          comboDisplay.classList.add("active");
          comboText.textContent = "x" + combo;
          comboText.style.transform = "scale(1.2)";
          setTimeout(() => {
            comboText.style.transform = "scale(1)";
          }, 100);
          if (combo >= 5 && combo % 5 === 0) {
            showComboAlert(combo);
          }
        }
        clearTimeout(comboDisplay.resetTimer);
        comboDisplay.resetTimer = setTimeout(() => {
          comboDisplay.classList.remove("active");
          combo = 0;
        }, CONFIG.comboTime * 2);
      }
      function showComboAlert(comboCount) {
        const alert = document.getElementById("comboAlert");
        alert.textContent = "COMBO x" + comboCount + "!";
        alert.classList.remove("show");
        void alert.offsetWidth;
        alert.classList.add("show");
      }
      // ===== UI更新 =====
      function updateScoreDisplay() {
        const scoreDisplay = document.getElementById("scoreDisplay");
        scoreDisplay.textContent = score;
        scoreDisplay.style.transform = "scale(1.1)";
        setTimeout(() => {
          scoreDisplay.style.transform = "scale(1)";
        }, 100);
      }
      function updateLivesDisplay() {
        const livesPanel = document.getElementById("livesPanel");
        const lifeElements = livesPanel.querySelectorAll(".life");
        lifeElements.forEach((el, i) => {
          if (i < lives) {
            el.classList.remove("lost");
          } else {
            el.classList.add("lost");
          }
        });
      }
      // ===== 更新逻辑 =====
      function update() {
        if (gameState !== "playing") return;
        const dt = slowMotionFactor;
        for (let i = fruits.length - 1; i >= 0; i--) {
          const fruit = fruits[i];
          fruit.vy += CONFIG.gravity * dt;
          fruit.x += fruit.vx * dt;
          fruit.y += fruit.vy * dt;
          fruit.rotation += fruit.rotationSpeed * dt;
          if (fruit.y > gameHeight + 100 && !fruit.sliced && !fruit.isBomb) {
            createMissParticles(fruit.x, gameHeight);
            fruits.splice(i, 1);
            lives--;
            updateLivesDisplay();
            if (lives <= 0) {
              endGame();
              return;
            }
          }
          if (fruit.y > gameHeight + 150 || fruit.y < -200) {
            fruits.splice(i, 1);
          }
        }
        for (let i = slices.length - 1; i >= 0; i--) {
          const slice = slices[i];
          slice.vy += CONFIG.gravity * dt;
          slice.x += slice.vx * dt;
          slice.y += slice.vy * dt;
          slice.rotation += slice.rotationSpeed * dt;
          slice.alpha -= 0.015 * dt;
          if (slice.alpha <= 0 || slice.y > gameHeight + 100) {
            slices.splice(i, 1);
          }
        }
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.vy += 0.2 * dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= 0.02 * dt;
          p.alpha = p.life;
          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        }
        spawnFruit();
      }
      // ===== 渲染 =====
      function render() {
        ctx.clearRect(0, 0, gameWidth, gameHeight);
        drawBackground();
        if (slowMotionFactor < 1) {
          ctx.fillStyle = "rgba(0, 188, 212, 0.05)";
          ctx.fillRect(0, 0, gameWidth, gameHeight);
        }
        drawParticles();
        drawFruits();
        drawSlices();
        drawBladeTrail();
      }
      function drawBackground() {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.02)";
        ctx.lineWidth = 1;
        const gridSize = 50;
        for (let x = 0; x < gameWidth; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, gameHeight);
          ctx.stroke();
        }
        for (let y = 0; y < gameHeight; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(gameWidth, y);
          ctx.stroke();
        }
      }
      function drawFruits() {
        fruits.forEach((fruit) => {
          if (fruit.sliced) return;
          ctx.save();
          ctx.translate(fruit.x, fruit.y);
          ctx.rotate(fruit.rotation);
          if (fruit.isBomb) {
            drawBomb(fruit);
          } else {
            drawFruit(fruit);
          }
          ctx.restore();
        });
      }
      function drawFruit(fruit) {
        const r = fruit.radius;
        ctx.shadowColor = fruit.color;
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = fruit.color;
        ctx.fill();
        ctx.shadowBlur = 0;
        const gradient = ctx.createRadialGradient(
          -r * 0.3,
          -r * 0.3,
          0,
          0,
          0,
          r
        );
        gradient.addColorStop(0, "rgba(255, 255, 255, 0.4)");
        gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.1)");
        gradient.addColorStop(1, "rgba(0, 0, 0, 0.2)");
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        if (fruit.type && fruit.type.special === "freeze") {
          ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, r + 5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            ctx.beginPath();
            ctx.arc(
              Math.cos(angle) * (r - 10),
              Math.sin(angle) * (r - 10),
              3,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        } else {
          ctx.fillStyle = "#27ae60";
          ctx.beginPath();
          ctx.ellipse(0, -r - 5, 4, 8, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#2ecc71";
          ctx.beginPath();
          ctx.ellipse(5, -r - 2, 6, 4, Math.PI / 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      function drawBomb(bomb) {
        const r = bomb.radius;
        ctx.shadowColor = "#ff3366";
        ctx.shadowBlur = 30;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = "#1a1a2e";
        ctx.fill();
        ctx.shadowBlur = 0;
        const gradient = ctx.createLinearGradient(-r, -r, r, r);
        gradient.addColorStop(0, "rgba(255, 255, 255, 0.2)");
        gradient.addColorStop(0.5, "rgba(255, 255, 255, 0)");
        gradient.addColorStop(1, "rgba(255, 255, 255, 0.1)");
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.strokeStyle = "#8b7355";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, -r);
        ctx.quadraticCurveTo(10, -r - 15, 5, -r - 20);
        ctx.stroke();
        const time = Date.now() / 100;
        ctx.fillStyle = `hsl(${30 + Math.sin(time) * 20}, 100%, 60%)`;
        ctx.beginPath();
        ctx.arc(
          5 + Math.sin(time * 2) * 2,
          -r - 20 + Math.cos(time) * 2,
          5 + Math.sin(time) * 2,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.fillStyle = "#ff3366";
        ctx.font = `bold ${r * 0.8}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("X", 0, 0);
      }
      function drawSlices() {
        slices.forEach((slice) => {
          ctx.save();
          ctx.globalAlpha = slice.alpha;
          ctx.translate(slice.x, slice.y);
          ctx.rotate(slice.rotation);
          const r = slice.radius;
          ctx.beginPath();
          if (slice.side < 0) {
            ctx.arc(
              0,
              0,
              r,
              slice.angle + Math.PI / 2,
              slice.angle - Math.PI / 2
            );
          } else {
            ctx.arc(
              0,
              0,
              r,
              slice.angle - Math.PI / 2,
              slice.angle + Math.PI / 2
            );
          }
          ctx.closePath();
          ctx.fillStyle = slice.color;
          ctx.fill();
          ctx.beginPath();
          if (slice.side < 0) {
            ctx.arc(
              0,
              0,
              r * 0.85,
              slice.angle + Math.PI / 2,
              slice.angle - Math.PI / 2
            );
          } else {
            ctx.arc(
              0,
              0,
              r * 0.85,
              slice.angle - Math.PI / 2,
              slice.angle + Math.PI / 2
            );
          }
          ctx.closePath();
          ctx.fillStyle = slice.innerColor;
          ctx.fill();
          ctx.restore();
        });
      }
      function drawParticles() {
        particles.forEach((p) => {
          ctx.globalAlpha = p.alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, Math.max(0.5, p.radius * p.alpha), 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;
      }
      function drawBladeTrail() {
        if (bladeTrail.length < 2) return;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 20;
        for (let i = 1; i < bladeTrail.length; i++) {
          const prev = bladeTrail[i - 1];
          const curr = bladeTrail[i];
          const progress = i / bladeTrail.length;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          const gradient = ctx.createLinearGradient(
            prev.x,
            prev.y,
            curr.x,
            curr.y
          );
          gradient.addColorStop(0, `rgba(255, 255, 255, ${progress * 0.3})`);
          gradient.addColorStop(1, `rgba(255, 255, 255, ${progress})`);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = progress * 12;
          ctx.stroke();
        }
        for (let i = 1; i < bladeTrail.length; i++) {
          const prev = bladeTrail[i - 1];
          const curr = bladeTrail[i];
          const progress = i / bladeTrail.length;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.strokeStyle = `rgba(255, 255, 255, ${progress})`;
          ctx.lineWidth = progress * 3;
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
      }
      // ===== 游戏循环 =====
      function gameLoop() {
        update();
        render();
        animationId = requestAnimationFrame(gameLoop);
      }
      // 启动游戏
      init();
    </script>
  </body>
</html>
