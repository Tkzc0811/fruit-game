<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="full-screen" content="yes">
  <title>水果忍者大师版</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0a12;
      --bg-glow: #1a0a2e;
      --accent: #ff3366;
      --accent-glow: #ff6b9d;
      --gold: #ffd700;
      --text: #f0f0f5;
      --muted: #6b6b8a;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg-dark);
      font-family: 'Noto Sans SC', sans-serif;
      position: fixed;
      top: 0;
      left: 0;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at 50% 100%, #1a0a2e 0%, #0a0a12 50%, #050508 100%);
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    /* UI层 */
    .ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    .score-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .score-display {
      font-family: 'Orbitron', monospace;
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 900;
      color: var(--text);
      text-shadow: 0 0 20px rgba(255, 51, 102, 0.5);
      transition: transform 0.1s ease;
    }
    .score-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .combo-display {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s ease;
    }
    .combo-display.active {
      opacity: 1;
      transform: scale(1);
    }
    .combo-text {
      font-family: 'Orbitron', monospace;
      font-size: clamp(24px, 5vw, 40px);
      font-weight: 700;
      color: var(--gold);
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
    }
    .combo-label {
      font-size: 11px;
      color: var(--gold);
      opacity: 0.8;
    }
    .lives-panel {
      position: absolute;
      bottom: 25px;
      left: 20px;
      display: flex;
      gap: 8px;
    }
    .life {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #ff4757, #c0392b);
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(255, 71, 87, 0.6);
      transition: all 0.3s ease;
    }
    .life.lost {
      background: #2a2a3a;
      box-shadow: none;
      transform: scale(0.8);
    }
    /* 飘分动画 */
    .floating-score {
      position: absolute;
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      pointer-events: none;
      animation: floatUp 0.8s ease-out forwards;
      z-index: 50;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
    }
    /* 连击提示 */
    .combo-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-size: clamp(32px, 8vw, 64px);
      font-weight: 900;
      color: var(--gold);
      text-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
      pointer-events: none;
      opacity: 0;
      z-index: 60;
    }
    .combo-alert.show {
      animation: comboFlash 0.6s ease-out forwards;
    }
    @keyframes comboFlash {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    /* 开始/结束画面 */
    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 5, 8, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 30px;
      pointer-events: auto;
      z-index: 100;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    .overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .game-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(36px, 10vw, 72px);
      font-weight: 900;
      color: var(--text);
      text-align: center;
      line-height: 1.1;
    }
    .game-subtitle {
      font-size: clamp(14px, 3vw, 18px);
      color: var(--muted);
      text-align: center;
      max-width: 300px;
      line-height: 1.6;
    }
    .final-score {
      font-family: 'Orbitron', monospace;
      font-size: clamp(48px, 12vw, 96px);
      font-weight: 900;
      color: var(--gold);
      text-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
    }
    .start-btn {
      padding: 16px 48px;
      font-family: 'Orbitron', monospace;
      font-size: 18px;
      font-weight: 700;
      color: var(--bg-dark);
      background: linear-gradient(135deg, var(--accent), var(--accent-glow));
      border: none;
      border-radius: 50px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 10px 40px rgba(255, 51, 102, 0.4);
      transition: all 0.3s ease;
    }
    .start-btn:active {
      transform: scale(0.95);
    }
    .high-score {
      font-size: 14px;
      color: var(--muted);
    }
    .high-score span {
      color: var(--gold);
      font-weight: 700;
    }
    .difficulty-badge {
      position: absolute;
      top: 80px;
      left: 20px;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .difficulty-badge.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
      <div class="score-panel">
        <span class="score-label">得分</span>
        <div class="score-display" id="scoreDisplay">0</div>
      </div>
      <div class="combo-display" id="comboDisplay">
        <div class="combo-text" id="comboText">x2</div>
        <div class="combo-label">连击</div>
      </div>
      <div class="lives-panel" id="livesPanel">
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
      </div>
      <div class="difficulty-badge" id="difficultyBadge"></div>
    </div>
    <div class="combo-alert" id="comboAlert">COMBO x5!</div>
    <!-- 开始画面 -->
    <div class="overlay" id="startOverlay">
      <h1 class="game-title">FRUIT<br>NINJA</h1>
      <p class="game-subtitle">滑动切割水果，避开炸弹<br>漏掉水果会失去生命</p>
      <button class="start-btn" id="startBtn">开始游戏</button>
      <p class="high-score">最高分: <span id="highScoreStart">0</span></p>
    </div>
    <!-- 结束画面 -->
    <div class="overlay hidden" id="gameOverOverlay">
      <h1 class="game-title">GAME OVER</h1>
      <div class="final-score" id="finalScore">0</div>
      <p class="high-score">最高分: <span id="highScoreEnd">0</span></p>
      <button class="start-btn" id="restartBtn">再来一次</button>
    </div>
  </div>
  <script>
    // ===== 音效系统 =====
    class SoundManager {
      constructor() { this.ctx = null; this.initialized = false; }
      init() {
        if (this.initialized) return;
        try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.initialized = true; } 
        catch (e) { console.error("Web Audio API not supported"); }
      }
      playSlice() {
        if (!this.ctx) return; const now = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 0.1, buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate), data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource(); noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 1000 + Math.random() * 500; filter.Q.value = 1;
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination); noise.start(now); noise.stop(now + 0.1);
      }
      playBomb() {
        if (!this.ctx) return; const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        const bufferSize = this.ctx.sampleRate * 0.5, buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate), data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource(); noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1000;
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.connect(gain); noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination); osc.start(now); osc.stop(now + 0.5); noise.start(now); noise.stop(now + 0.5);
      }
      playMiss() {
        if (!this.ctx) return; const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(150, now + 0.2);
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(now); osc.stop(now + 0.2);
      }
      playCombo(level) {
        if (!this.ctx) return; const now = this.ctx.currentTime;
        const baseFreq = 600 + level * 50, osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = baseFreq;
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(now); osc.stop(now + 0.1);
      }
    }
    const soundManager = new SoundManager();
    // ===== 游戏配置 =====
    const CONFIG = {
      gravity: 0.18,             // 再次降低重力，使下落更慢
      initialSpawnRate: 2000,    // 初始生成间隔
      minSpawnRate: 800,         // 最快生成间隔
      bombChance: 0.12,
      maxLives: 5,
      comboTime: 800,
      bladeTrailLength: 20,
    };
    // ===== 难度等级定义 =====
    // 调整了难度阈值，让前期更轻松
    const DIFFICULTY_LEVELS = [
      { name: '简单', color: '#27ae60', threshold: 0, maxFruits: 2, bombChanceMod: 0, speedMod: 0 },
      { name: '普通', color: '#f39c12', threshold: 50, maxFruits: 3, bombChanceMod: 0.05, speedMod: 0.5 },
      { name: '困难', color: '#e74c3c', threshold: 120, maxFruits: 4, bombChanceMod: 0.08, speedMod: 1 },
      { name: '噩梦', color: '#9b59b6', threshold: 200, maxFruits: 5, bombChanceMod: 0.10, speedMod: 1.5 },
      { name: '地狱', color: '#ff3366', threshold: 350, maxFruits: 7, bombChanceMod: 0.15, speedMod: 2 },
    ];
    // ===== 水果类型定义 =====
    const FRUIT_TYPES = [
      { name: 'apple', color: '#e74c3c', innerColor: '#f5d6ba', points: 1, radius: 32 },
      { name: 'orange', color: '#f39c12', innerColor: '#ffeaa7', points: 1, radius: 30 },
      { name: 'watermelon', color: '#27ae60', innerColor: '#ff6b6b', points: 2, radius: 40 },
      { name: 'lemon', color: '#f1c40f', innerColor: '#fffde7', points: 1, radius: 26 },
      { name: 'grape', color: '#9b59b6', innerColor: '#d4a5e8', points: 1, radius: 24 },
      { name: 'kiwi', color: '#795548', innerColor: '#a4d65e', points: 1, radius: 28 },
      { name: 'freeze', color: '#00bcd4', innerColor: '#e0f7fa', points: 3, radius: 34, special: 'freeze' },
    ];
    // ===== 游戏状态 =====
    let canvas, ctx, gameWidth = 0, gameHeight = 0, dpr = 1;
    let gameState = 'menu', score = 0, highScore = parseInt(localStorage.getItem('fruitNinjaHighScore') || '0'), lives = CONFIG.maxLives;
    let combo = 0, lastComboTime = 0, lastSpawnTime = 0, animationId = null;
    let currentDifficulty = DIFFICULTY_LEVELS[0], slowMotionFactor = 1, slowMotionTimeout = null;
    let fruits = [], slices = [], particles = [], bladeTrail = [], isSlicing = false, sliceStart = null;
    // ===== 初始化 =====
    function init() {
      canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d');
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      document.getElementById('highScoreStart').textContent = highScore;
      document.getElementById('highScoreEnd').textContent = highScore;
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('restartBtn').addEventListener('click', startGame);
      canvas.addEventListener('mousedown', onSliceStart); canvas.addEventListener('mousemove', onSliceMove);
      canvas.addEventListener('mouseup', onSliceEnd); canvas.addEventListener('mouseleave', onSliceEnd);
      canvas.addEventListener('touchstart', onTouchStart, { passive: false });
      canvas.addEventListener('touchmove', onTouchMove, { passive: false });
      canvas.addEventListener('touchend', onSliceEnd); canvas.addEventListener('touchcancel', onSliceEnd);
      requestAnimationFrame(gameLoop);
    }
    function resizeCanvas() {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      gameWidth = window.innerWidth; gameHeight = window.innerHeight;
      canvas.width = gameWidth * dpr; canvas.height = gameHeight * dpr;
      canvas.style.width = gameWidth + 'px'; canvas.style.height = gameHeight + 'px';
      ctx.scale(dpr, dpr);
    }
    function startGame() {
      soundManager.init();
      gameState = 'playing'; score = 0; lives = CONFIG.maxLives; combo = 0;
      fruits = []; slices = []; particles = []; bladeTrail = [];
      lastSpawnTime = Date.now();
      currentDifficulty = DIFFICULTY_LEVELS[0]; slowMotionFactor = 1;
      updateScoreDisplay(); updateLivesDisplay();
      document.getElementById('startOverlay').classList.add('hidden');
      document.getElementById('gameOverOverlay').classList.add('hidden');
    }
    function endGame() {
      gameState = 'gameover'; slowMotionFactor = 1;
      if (score > highScore) { highScore = score; localStorage.setItem('fruitNinjaHighScore', highScore.toString()); }
      document.getElementById('finalScore').textContent = score;
      document.getElementById('highScoreEnd').textContent = highScore;
      document.getElementById('gameOverOverlay').classList.remove('hidden');
      document.getElementById('difficultyBadge').classList.remove('show');
    }
    function updateDifficulty() {
      let newDifficulty = DIFFICULTY_LEVELS[0];
      for (let i = DIFFICULTY_LEVELS.length - 1; i >= 0; i--) {
        if (score >= DIFFICULTY_LEVELS[i].threshold) { newDifficulty = DIFFICULTY_LEVELS[i]; break; }
      }
      if (newDifficulty !== currentDifficulty) { currentDifficulty = newDifficulty; showDifficultyBadge(); }
    }
    function showDifficultyBadge() {
      const badge = document.getElementById('difficultyBadge');
      badge.textContent = currentDifficulty.name;
      badge.style.backgroundColor = currentDifficulty.color;
      badge.style.color = '#fff'; badge.classList.add('show');
    }
    function getSpawnRate() {
      const rateReduction = score * 3; // 进一步放缓难度增长速度
      return Math.max(CONFIG.minSpawnRate, CONFIG.initialSpawnRate - rateReduction);
    }
    // ===== 生成水果 (核心物理调整) =====
    function spawnFruit() {
      if (gameState !== 'playing') return;
      const now = Date.now();
      if (now - lastSpawnTime < getSpawnRate()) return;
      lastSpawnTime = now;
      const count = 1 + Math.floor(Math.random() * currentDifficulty.maxFruits);
      let bombCount = 0;
      const totalBombChance = CONFIG.bombChance + currentDifficulty.bombChanceMod;
      if (Math.random() < totalBombChance && score > 30) { // 提高炸弹出现门槛
        bombCount = 1;
        if (currentDifficulty.name === '地狱' && Math.random() < 0.2) bombCount = 2;
      }
      const fruitCount = count - bombCount;
      const segmentWidth = gameWidth / count;
      const itemsToSpawn = [];
      for (let i = 0; i < fruitCount; i++) {
        itemsToSpawn.push({ type: 'fruit', data: FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)] });
      }
      for (let i = 0; i < bombCount; i++) itemsToSpawn.push({ type: 'bomb', data: null });
      // 随机打乱位置
      for (let i = itemsToSpawn.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [itemsToSpawn[i], itemsToSpawn[j]] = [itemsToSpawn[j], itemsToSpawn[i]];
      }
      itemsToSpawn.forEach((item, index) => {
        const baseX = (segmentWidth * index) + (segmentWidth / 2);
        const randomOffsetX = (Math.random() - 0.5) * segmentWidth * 0.6;
        const x = Math.max(50, Math.min(gameWidth - 50, baseX + randomOffsetX));
        const y = gameHeight + 60;
        // 水平速度：向中心轻微靠拢，防止飞出屏幕
        const centerDist = (x - gameWidth / 2) / (gameWidth / 2);
        const vx = centerDist * -1.2 + (Math.random() - 0.5) * 1.0; 
        // 核心优化：垂直速度与高度计算
        // 目标：飞到屏幕高度的 50% 到 75% 位置（即屏幕中上部）
        // 使用公式 v = sqrt(2 * g * h)
        const targetH = gameHeight * (0.8 + Math.random() * 0.25); // 目标高度：屏幕的 50% ~ 75%
        let baseVy = Math.sqrt(2 * CONFIG.gravity * targetH);
        // 难度修正：让后期稍微快一点点，但不影响高度太大
        // 减少难度对速度的直接影响，保持舒缓节奏
        baseVy += currentDifficulty.speedMod * 0.5; 
        const vy = -baseVy; // 负号表示向上
        if (item.type === 'bomb') {
          fruits.push({ x, y, vx, vy, radius: 30, rotation: 0, rotationSpeed: (Math.random() - 0.5) * 0.1, isBomb: true, sliced: false, points: 0 });
        } else {
          const typeData = item.data;
          fruits.push({
            x, y, vx, vy, radius: typeData.radius, color: typeData.color,
            innerColor: typeData.innerColor, points: typeData.points,
            rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.15,
            type: typeData, isBomb: false, sliced: false
          });
        }
      });
    }
    // ===== 输入处理 =====
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function onSliceStart(e) {
      if (gameState !== 'playing') return;
      isSlicing = true; sliceStart = getPos(e); bladeTrail = [sliceStart];
    }
    function onSliceMove(e) {
      if (!isSlicing || gameState !== 'playing') return;
      const pos = getPos(e); bladeTrail.push(pos);
      if (bladeTrail.length > CONFIG.bladeTrailLength) bladeTrail.shift();
      checkSliceCollisions(pos);
    }
    function onSliceEnd() { isSlicing = false; sliceStart = null; setTimeout(() => { bladeTrail = []; }, 100); }
    function onTouchStart(e) {
      e.preventDefault();
      if (gameState !== 'playing') return;
      const touch = e.touches[0]; isSlicing = true; sliceStart = getPos(touch); bladeTrail = [sliceStart];
    }
    function onTouchMove(e) {
      e.preventDefault();
      if (!isSlicing || gameState !== 'playing') return;
      const touch = e.touches[0]; const pos = getPos(touch); bladeTrail.push(pos);
      if (bladeTrail.length > CONFIG.bladeTrailLength) bladeTrail.shift();
      checkSliceCollisions(pos);
    }
    // ===== 碰撞检测 =====
    function checkSliceCollisions(pos) {
      if (bladeTrail.length < 2) return;
      const prev = bladeTrail[bladeTrail.length - 2], curr = pos;
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        if (fruit.sliced) continue;
        if (lineCircleCollision(prev, curr, fruit)) {
          if (fruit.isBomb) { soundManager.playBomb(); createExplosion(fruit); fruits.splice(i, 1); endGame(); return; }
          else { sliceFruit(fruit, i, curr); }
        }
      }
    }
    function lineCircleCollision(p1, p2, circle) {
      const dx = p2.x - p1.x, dy = p2.y - p1.y, fx = p1.x - circle.x, fy = p1.y - circle.y;
      const a = dx * dx + dy * dy; if (a === 0) return false;
      const b = 2 * (fx * dx + fy * dy), c = fx * fx + fy * fy - circle.radius * circle.radius;
      let discriminant = b * b - 4 * a * c; if (discriminant < 0) return false;
      discriminant = Math.sqrt(discriminant);
      const t1 = (-b - discriminant) / (2 * a), t2 = (-b + discriminant) / (2 * a);
      return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
    }
    // ===== 游戏逻辑 =====
    function sliceFruit(fruit, index, slicePos) {
      fruit.sliced = true; soundManager.playSlice();
      if (fruit.type && fruit.type.special === 'freeze') activateSlowMotion();
      const angle = Math.atan2(bladeTrail[bladeTrail.length - 1].y - bladeTrail[0].y, bladeTrail[bladeTrail.length - 1].x - bladeTrail[0].x);
      slices.push(createSlice(fruit, angle, -1)); slices.push(createSlice(fruit, angle, 1));
      createJuiceParticles(fruit, slicePos);
      updateCombo();
      const pointsGained = fruit.points * combo;
      score += pointsGained;
      showFloatingScore(slicePos.x, slicePos.y, pointsGained, combo > 1);
      updateScoreDisplay(); updateDifficulty();
      fruits.splice(index, 1);
    }
    function activateSlowMotion() { slowMotionFactor = 0.5; if (slowMotionTimeout) clearTimeout(slowMotionTimeout); slowMotionTimeout = setTimeout(() => { slowMotionFactor = 1; }, 2000); }
    function showFloatingScore(x, y, points, isCombo) {
      const container = document.getElementById('gameContainer'); const floatingDiv = document.createElement('div');
      floatingDiv.className = 'floating-score'; floatingDiv.textContent = '+' + points;
      floatingDiv.style.left = x + 'px'; floatingDiv.style.top = y + 'px';
      if (isCombo) { floatingDiv.style.color = '#ffd700'; floatingDiv.style.fontSize = '24px'; floatingDiv.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8)'; }
      else { floatingDiv.style.color = '#ffffff'; floatingDiv.style.fontSize = '18px'; }
      container.appendChild(floatingDiv); setTimeout(() => { floatingDiv.remove(); }, 800);
    }
    function createSlice(fruit, angle, side) {
      return { x: fruit.x, y: fruit.y, vx: fruit.vx + side * Math.cos(angle + Math.PI/2) * 8, vy: fruit.vy + side * Math.sin(angle + Math.PI/2) * 8 - 5, radius: fruit.radius, color: fruit.color, innerColor: fruit.innerColor, angle: angle, rotation: fruit.rotation, rotationSpeed: fruit.rotationSpeed + side * 0.1, alpha: 1, type: fruit.type, side: side, isSpecial: fruit.type && fruit.type.special };
    }
    function createJuiceParticles(fruit, pos) {
      const particleCount = 15 + Math.floor(fruit.radius / 3);
      for (let i = 0; i < particleCount; i++) { const angle = Math.random() * Math.PI * 2, speed = 2 + Math.random() * 6; particles.push({ x: pos.x, y: pos.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 2, radius: 2 + Math.random() * 4, color: fruit.innerColor, alpha: 1, life: 1 }); }
    }
    function createExplosion(bomb) { for (let i = 0; i < 60; i++) { const angle = Math.random() * Math.PI * 2, speed = 5 + Math.random() * 15; particles.push({ x: bomb.x, y: bomb.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: 3 + Math.random() * 8, color: i % 2 === 0 ? '#ff3366' : '#ffcc00', alpha: 1, life: 1 }); } }
    function createMissParticles(x, y) { for (let i = 0; i < 10; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 4, vy: -Math.random() * 3, radius: 3 + Math.random() * 3, color: '#ff4757', alpha: 1, life: 1 }); } }
    function updateCombo() {
      const now = Date.now();
      if (now - lastComboTime < CONFIG.comboTime) combo = Math.min(combo + 1, 10); else combo = 1;
      lastComboTime = now;
      if (combo > 1) {
        soundManager.playCombo(combo);
        const comboDisplay = document.getElementById('comboDisplay'), comboText = document.getElementById('comboText');
        comboDisplay.classList.add('active'); comboText.textContent = 'x' + combo;
        comboText.style.transform = 'scale(1.2)'; setTimeout(() => { comboText.style.transform = 'scale(1)'; }, 100);
        if (combo >= 5 && combo % 5 === 0) showComboAlert(combo);
      }
      clearTimeout(window.comboResetTimer);
      window.comboResetTimer = setTimeout(() => { document.getElementById('comboDisplay').classList.remove('active'); combo = 0; }, CONFIG.comboTime * 2);
    }
    function showComboAlert(comboCount) { const alert = document.getElementById('comboAlert'); alert.textContent = 'COMBO x' + comboCount + '!'; alert.classList.remove('show'); void alert.offsetWidth; alert.classList.add('show'); }
    function updateScoreDisplay() { const scoreDisplay = document.getElementById('scoreDisplay'); scoreDisplay.textContent = score; scoreDisplay.style.transform = 'scale(1.1)'; setTimeout(() => { scoreDisplay.style.transform = 'scale(1)'; }, 100); }
    function updateLivesDisplay() { const lifeElements = document.getElementById('livesPanel').querySelectorAll('.life'); lifeElements.forEach((el, i) => { if (i < lives) el.classList.remove('lost'); else el.classList.add('lost'); }); }
    // ===== 主循环 =====
    function update() {
      if (gameState !== 'playing') return;
      const dt = slowMotionFactor;
      for (let i = fruits.length - 1; i >= 0; i--) {
        const fruit = fruits[i];
        fruit.vy += CONFIG.gravity * dt;
        fruit.x += fruit.vx * dt;
        fruit.y += fruit.vy * dt;
        fruit.rotation += fruit.rotationSpeed * dt;
        if (fruit.y > gameHeight + 100 && !fruit.sliced && !fruit.isBomb) {
          soundManager.playMiss(); createMissParticles(fruit.x, gameHeight); fruits.splice(i, 1); lives--; updateLivesDisplay();
          if (lives <= 0) endGame();
        }
        if (fruit.y > gameHeight + 200 || fruit.y < -gameHeight) fruits.splice(i, 1);
      }
      for (let i = slices.length - 1; i >= 0; i--) {
        const slice = slices[i];
        slice.vy += CONFIG.gravity * dt; slice.x += slice.vx * dt; slice.y += slice.vy * dt;
        slice.rotation += slice.rotationSpeed * dt; slice.alpha -= 0.015 * dt;
        if (slice.alpha <= 0 || slice.y > gameHeight + 100) slices.splice(i, 1);
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.vy += 0.2 * dt; p.x += p.vx * dt; p.y += p.vy * dt;
        p.life -= 0.02 * dt; p.alpha = p.life;
        if (p.life <= 0) particles.splice(i, 1);
      }
      spawnFruit();
    }
    function render() {
      ctx.clearRect(0, 0, gameWidth, gameHeight);
      drawBackground();
      if (slowMotionFactor < 1) { ctx.fillStyle = 'rgba(0, 188, 212, 0.05)'; ctx.fillRect(0, 0, gameWidth, gameHeight); }
      drawParticles(); drawFruits(); drawSlices(); drawBladeTrail();
    }
    function drawBackground() {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)'; ctx.lineWidth = 1; const gridSize = 50;
      for (let x = 0; x < gameWidth; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, gameHeight); ctx.stroke(); }
      for (let y = 0; y < gameHeight; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(gameWidth, y); ctx.stroke(); }
    }
    function drawFruits() { fruits.forEach(fruit => { if (fruit.sliced) return; ctx.save(); ctx.translate(fruit.x, fruit.y); ctx.rotate(fruit.rotation); if (fruit.isBomb) drawBomb(fruit); else drawFruit(fruit); ctx.restore(); }); }
    function drawFruit(fruit) {
      const r = fruit.radius;
      ctx.shadowColor = fruit.color; ctx.shadowBlur = 20;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = fruit.color; ctx.fill();
      ctx.shadowBlur = 0;
      const gradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, 0, 0, r);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)'); gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
      if (fruit.type && fruit.type.special === 'freeze') {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r + 5, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; for (let i = 0; i < 6; i++) { const angle = (i / 6) * Math.PI * 2; ctx.beginPath(); ctx.arc(Math.cos(angle) * (r - 10), Math.sin(angle) * (r - 10), 3, 0, Math.PI * 2); ctx.fill(); }
      } else {
        ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.ellipse(0, -r - 5, 4, 8, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.ellipse(5, -r - 2, 6, 4, Math.PI / 4, 0, Math.PI * 2); ctx.fill();
      }
    }
    function drawBomb(bomb) {
      const r = bomb.radius;
      ctx.shadowColor = '#ff3366'; ctx.shadowBlur = 30;
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = '#1a1a2e'; ctx.fill();
      ctx.shadowBlur = 0;
      const gradient = ctx.createLinearGradient(-r, -r, r, r);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)'); gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
      ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
      ctx.strokeStyle = '#8b7355'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -r); ctx.quadraticCurveTo(10, -r - 15, 5, -r - 20); ctx.stroke();
      const time = Date.now() / 100;
      ctx.fillStyle = `hsl(${30 + Math.sin(time) * 20}, 100%, 60%)`;
      ctx.beginPath(); ctx.arc(5 + Math.sin(time * 2) * 2, -r - 20 + Math.cos(time) * 2, 5 + Math.sin(time) * 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff3366'; ctx.font = `bold ${r * 0.8}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('X', 0, 0);
    }
    function drawSlices() {
      slices.forEach(slice => {
        ctx.save(); ctx.globalAlpha = slice.alpha; ctx.translate(slice.x, slice.y); ctx.rotate(slice.rotation);
        const r = slice.radius;
        ctx.beginPath();
        if (slice.side < 0) ctx.arc(0, 0, r, slice.angle + Math.PI/2, slice.angle - Math.PI/2); else ctx.arc(0, 0, r, slice.angle - Math.PI/2, slice.angle + Math.PI/2);
        ctx.closePath(); ctx.fillStyle = slice.color; ctx.fill();
        ctx.beginPath();
        if (slice.side < 0) ctx.arc(0, 0, r * 0.85, slice.angle + Math.PI/2, slice.angle - Math.PI/2); else ctx.arc(0, 0, r * 0.85, slice.angle - Math.PI/2, slice.angle + Math.PI/2);
        ctx.closePath(); ctx.fillStyle = slice.innerColor; ctx.fill();
        ctx.restore();
      });
    }
    function drawParticles() { particles.forEach(p => { ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.5, p.radius * p.alpha), 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1; }
    function drawBladeTrail() {
      if (bladeTrail.length < 2) return;
      ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 20;
      for (let i = 1; i < bladeTrail.length; i++) {
        const prev = bladeTrail[i - 1], curr = bladeTrail[i], progress = i / bladeTrail.length;
        ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y);
        const gradient = ctx.createLinearGradient(prev.x, prev.y, curr.x, curr.y);
        gradient.addColorStop(0, `rgba(255, 255, 255, ${progress * 0.3})`); gradient.addColorStop(1, `rgba(255, 255, 255, ${progress})`);
        ctx.strokeStyle = gradient; ctx.lineWidth = progress * 12; ctx.stroke();
      }
      for (let i = 1; i < bladeTrail.length; i++) {
        const prev = bladeTrail[i - 1], curr = bladeTrail[i], progress = i / bladeTrail.length;
        ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${progress})`; ctx.lineWidth = progress * 3; ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    function gameLoop() { update(); render(); animationId = requestAnimationFrame(gameLoop); }
    init();
  </script>
</body>
</html>
